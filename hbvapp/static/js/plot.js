/*
  plot.js contains functions to generate plots using library plotly.js. Plots
  generated by Bokeh python is not as interactive as expected. For example, it
  is hard to call a callback function when we want to use values on the graph.
  And another idea is that plotly.js is capable to append/add traces(glyphs)
  dynamically by updating data, which is more efficient and less complicated than
  using Bokeh to generate <div>s and <script>s sent by post.
*/

function HBV() {
  var hbv = new Object();
  // c stands for Context object
  hbv.c = new Context();
  // d stands for Data object
  hbv.d = new Data();
  // p stands for Plot object
  hbv.p = new Object();
  // s stands for Schema object
  hbv.s = new Schema();
  // info stands for Information object
  hbv.info = new Object();
  return hbv;
}

// Data object constructors
function Data () {
  var init_data = new Array();
  var data = new Array();

  function initialize(text) {
  /*
    Function to read parse local csv text and generate init_data of Data object
  */
    var delimiter = hbv.c.context.id_csvSeparatorInput,
        header = parseInt(hbv.c.context.id_csvHeaderInput);

    var data = d3.dsvFormat(delimiter).parse(text, function(d, i) {
      return {
        date: moment(d.date).format("YYYY-MM-DD"),  // Date
        prec: +d.prec,     // Precipitation
        q_rec: +d.q_rec,   // Recorded discharge
        temp: +d.temp,     // Air temperature
        tm: +d.tm,         // Monthly mean air temperature
        ep: +d.ep,         // Evaporation
      };
    });

    function data_validator() {
      return undefined;
    }

    this.init_data = data;
    return undefined;
  } // <-- initialize -->

  function synthesize(d) {
  /*
    synthesize() generates a dataframe-like js object to serve as Data.data
    element.
    Input d : np.array-like data frame by POST, already has simulation results.
  */
    var dat = new Object();
    var names = ['date', 'q_rec', 'q_sim', 'ep', 'temp', 'tm', 'sp','wc', 'sm', 'lz', 'uz'];

    for (col_name of names) {
      var col = d.map(function(row){
        return row[col_name];
      });
      dat[col_name] = col;
    }

    if (hbv.c.context.push) {
      /* Push into Data.data in push mode */
      this.data.push(dat);
    }
    else {
      this.data[hbv.data.length - 1] = dat;
    }
    return undefined;
  } // <-- synthesize -->

  function find_max(name, i, begin, end) {
  /*
    Function to find maxi in the given array
  */
    var max = Math.max.apply(Math, this.data[i][name].slice(begin, end+1));
    if (max == NaN) {
      var ex = new Error(`Gap presents in the ${name} data !`);
      throw ex;
    }
    else {
      return max;
    }
  }

  function find_min(name, i, begin, end) {
  /*
    Function to find mini in the given array
  */
    var min = Math.min.apply(Math, this.data[i][name].slice(begin, end+1));
    if (min == NaN) {
      var ex = new Error(`Gap presents in the ${name} data !`);
      throw ex;
    }
    else {
      return min;
    }
  }

  return {init_data:init_data, data:data, find_max:find_max, find_min:find_min,
    initialize:initialize, synthesize:synthesize};
}

/*
  Prototype Schema contains the schema of the HBV tanks and the corresponding
  water levels in the thank. Basically we use D3.js here to realize both the static
  drawing and the transition. D3 will generate water tanks which are mainly static,
  and water levels controled by a scroll bar indicating time(date in our case). To
  previlige D3's data-driven nature, we will use the DataFrame generated by pyhton
  as our input data here.
*/

function Schema() {
  var svg = d3.select(".schemaSvg");
  var p_width = [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1, 1.125, 1.25];
  var tanks = new Object();

  // Value, a factor to multiple with tanks' heights
  var value = 2.0/3.0;

  // Minimum depth, to prevent zero or negative value
  var base = 2.0/15.0;

  // Maximal height of water levels
  var maxh = 0.85;

  function generate_key_cords(){
    var x = parseInt(this.svg.select("#main_soil").attr("x"));
    var y = parseInt(this.svg.select("#main_soil").attr("y"));
    var w_soil = parseInt(this.svg.select("#main_soil").attr("width"));
    var h_soil = parseInt(this.svg.select("#main_soil").attr("height"));

    var soil = {
      x: x,
      y: y,
      width: w_soil,
      height: h_soil,
      stroke: 4,
      };

    var uz = {
      x: 2,
      y: 438,
      x1: 242,
      y1: 546,
      stroke: 4,
      get width() {
        return (this.x1-this.x);
      },
      get height() {
        return (this.y1-this.y);
      },
    };

    var lz = {
      x: 2,
      y: 621,
      x1: 242,
      y1: 729,
      stroke: 4,
      get width() {
        return (this.x1-this.x);
      },
      get height() {
        return (this.y1-this.y);
      },
    };

    var int_cords = {soil: soil, uz: uz, lz: lz};
    this.cords = int_cords;
  }

  function generate_main(name, cords) {
    var cord = cords[name];
    var value = this.value;
    var tank = this.svg.append("rect")
                      .attr("x", function(){
                        return (cord.x+0.6*cord.stroke);
                       })
                      .attr("y", function(){
                        return (cord.height*(1-value)+cord.y);
                       })
                      .attr("width", function(){
                        return cord.width-0.9*cord.stroke;
                       })
                      .attr("height", function(){
                        return parseInt(cord.height*value);
                       })
                      .attr("fill", "#3333cc")
                      .attr("fill-opacity", 0.4)
                      .attr("id", name);
    return tank;
  }

  function generate_shade(tank) {
    var name = tank.attr("id");
    var stroke = 4;

    var surf = this.svg.append("path")
                        .attr("stroke", "#0f0f3e")
                        .attr("stroke-width", 3)
                        .attr("stroke-opacity", 0.7)
                        .attr("class", "surf")
                        .attr("d", function(){
                          var x = tank.attr("x").toFloat();
                          var y = tank.attr("y").toFloat();
                          var length = tank.attr("width").toFloat() + 1.5*stroke;
                          return `M ${x} ${y} H ${length}`;
                        });

    var shade_clip = this.svg.append("clipPath")
                              .attr("id", `${name}_shade_container`)
                              .append("rect")
                              .attr("x", function(){return tank.attr('x').toFloat()+1;})
                              .attr("y", function(){return tank.attr('y').toFloat();})
                              .attr("width", function(){
                                var w = tank.attr('width').toFloat() - 2;
                                return w;
                              })
                              .attr("height", function(){
                                var h = tank.attr('height').toFloat() - 1;
                                return h;
                              })
                              .attr("fill", "#ccffff")
                              .attr("class", "shade_clip");

    var shade = this.svg.selectAll("#shade")
                        .data(this.p_width)
                        .enter()
                        .append("path")
                        .attr("d", function(d){
                          var x0 = tank.attr('x').toFloat() + tank.attr('width').toFloat() * d;
                          var y0 = tank.attr('y').toFloat();
                          var x1 = x0-tank.attr('height').toFloat();
                          var y1 = tank.attr('y').toFloat()+tank.attr('height').toFloat();
                          return `M ${x0} ${y0} L ${x1} ${y1}`;
                        })
                        .attr("stroke", "#3366ff")
                        .attr("stroke-width", 2)
                        .attr("stroke-opacity", 0.5)
                        .attr("clip-path", `url(#${name}_shade_container)`)
                        .attr("class", "shade");

    return {surf: surf, shade_clip: shade_clip, shade: shade, name: name};
  }

  function init_animation() {
    var value = this.value;
    var int_tanks = { mains: {}, shades: {} };
    this.generate_key_cords();

    int_tanks.mains.soil = this.generate_main('soil', this.cords);
    int_tanks.shades.soil = this.generate_shade(int_tanks.mains.soil);
    int_tanks.mains.uz = this.generate_main('uz', this.cords);
    int_tanks.shades.uz = this.generate_shade(int_tanks.mains.uz);
    int_tanks.mains.lz = this.generate_main('lz', this.cords);
    int_tanks.shades.lz = this.generate_shade(int_tanks.mains.lz);
    this.tanks = int_tanks;
    return undefined;
  }

  function trans(name, value) {
    var left = 0;//indexOf();
    var right = 2312;//indexOf();
    var col_name = "";
    (name=="soil") ? col_name = "sm" : col_name = name;

    var max = hbv.d.find_max(col_name, this.latest, left, right),
        min = hbv.d.find_min(col_name, this.latest, left, right);

    var fill = 1 - (max-value)/(max-min);

    var main = this.tanks.mains[name],
        shade = this.tanks.shades[name];

    var cords = this.cords[name];
    var ys = (cords.height*(1-fill)+cords.y).toFixed(2);
    var heights = (cords.height*fill).toFixed(2);

    main.transition()
        .attr("y", ys)
        .attr("height", heights);

    shade.surf.transition()
              .attr("d", function(){
                var x = main.attr("x").toFloat();
                var y = ys;
                var length = main.attr("width").toFloat() + 1.5*cords.stroke;
                return `M ${x} ${y} H ${length}`;
              });

    shade.shade_clip.transition()
                    .attr("y", ys)
                    .attr("height", heights);

    shade.shade.transition()
               .attr("d", function(d){
                  var x0 = main.attr('x').toFloat() + main.attr('width').toFloat() * d;
                  var y0 = ys.toFloat();
                  var x1 = x0 - heights.toFloat();
                  var y1 = ys.toFloat() + heights.toFloat();
                  return `M ${x0} ${y0} L ${x1} ${y1}`;
                });
  }

  function point_to(index) {
    // df an object-like dataframe
    var df = hbv.d.data[this.latest];
    var date = df.date,
        sm = df.sm,
        uz = df.uz,
        lz = df.lz,
        wc = df.wc,
        sp = df.sp;

    this.trans("soil", sm[index]);
    this.trans("uz", uz[index]);
    this.trans("lz", lz[index]);
  }

  function init_slider() {
    var terminus = hbv.d.init_data.length-1;

    if (isEmpty(hbv.d.data)) {
      $("#id_date_slider").prop("disabled", true);
      alert("It seems that we have no data ! ");
    }
    else {
      if ($("#id_date_slider").prop("disabled")) {
        $("#id_date_slider").prop("disabled", false);
        $("#id_date_slider").prop("max", terminus);
      } else {
        $("#id_date_slider").prop("this.value", 0);
        $("#id_date_slider").prop("max", terminus);
      }
    }
  }

  // Prototype constructor interface
  var schema = {
    get latest() {  // Latest set of data
      var latest = hbv.d.data.length-1;
      return latest;
    },
    svg:svg, p_width:p_width, tanks:tanks, base:base, maxh:maxh, value:value,
    generate_key_cords:generate_key_cords, init_slider:init_slider,
    generate_main:generate_main, generate_shade:generate_shade,
    init_animation:init_animation, trans:trans, point_to:point_to
  };
  return schema;
}

function Plot() {

}

function Context() {
  var context = {
    "id_verbose":false,
    "id_minimise":true,
    "id_residus":"RMSE",
    "id_tolInput":"0.001",
    "id_warmUpInput":"10",
    "id_csvSeparatorInput":",",
    "id_csvHeaderInput":"0",
    "id_select_all_par":true,
    "id_select_date_range":false,
    "id_sci_note":true,
    "id_snow":true,
    "id_init_guess":false,
    "push":true,
    "id_perc":"",
    "id_alpha":"",
    "id_k1":"",
    "id_mbas":"",
    "id_k":"",
    "id_lz":"",
    "id_uz":"",
    "id_c_flux":"",
    "id_beta":"",
    "id_lp":"",
    "id_etf":"",
    "id_e_corr":"",
    "id_fc":"",
    "id_sm":"",
    "id_cfr":"",
    "id_cwh":"",
    "id_cfmax":"",
    "id_ttm":"",
    "id_utt":"",
    "id_ltt":"",
    "id_sfcf":"",
    "id_rfcf":"",
    "id_wc":"",
    "id_sp":"",
    "id_tfac":"",
    "id_area":"",
    "par_to_calibrate": { // Parameters to calibrate
      "id_perc":true,
      "id_alpha":true,
      "id_k1":true,
      "id_k":true,
      "id_c_flux":true,
      "id_beta":true,
      "id_lp":true,
      "id_etf":true,
      "id_e_corr":true,
      "id_fc":true,
      "id_cfr":true,
      "id_cwh":true,
      "id_cfmax":true,
      "id_ttm":true,
      "id_utt":true,
      "id_ltt":true,
      "id_sfcf":true,
      "id_rfcf":true,
    },
    "bounds":{
      P_LB:[],
      P_UB:[]
    },
  };
  var twins = [
    "id_perc",
    "id_alpha",
    "id_k1",
    "id_mbas",
    "id_k",
    "id_lz",
    "id_uz",
    "id_c_flux",
    "id_beta",
    "id_lp",
    "id_etf",
    "id_e_corr",
    "id_fc",
    "id_sm",
    "id_cfr",
    "id_cwh",
    "id_cfmax",
    "id_ttm",
    "id_utt",
    "id_ltt",
    "id_sfcf",
    "id_rfcf",
    "id_wc",
    "id_sp",
    "id_tfac",
    "id_area"
  ];

  function changeWhenInput(e){
  /*
    Function in charge of changing context of the client
  */
    var elem = e.target;
    var id = elem.id;
    var value = elem.value;

    (elem.hasAttribute("invalid")) ? null : hbv.c.context[id] = value;

    if (id == "id_RMSE" || id == "id_NSE") {
      if(elem.checked == true) {
        (id == "id_RMSE") ? hbv.c.context['id_residus'] = "RMSE" : hbv.c.context['id_residus'] = "NSE";
      }
    }
    else if (value=="boolean") {
      (elem.checked==true) ? hbv.c.context[id] = true : hbv.c.context[id] = false;
    }
    else if (hbv.c.twins.indexOf(id) >= 0) {
      var siblings = Object.values($(`input[id=${id}]`)).slice(0,2);
      siblings.forEach(function (element) {
        element.value = value;
        element.onchange();
      });
    }
    else {}
  }

  function changeWhenLoad(ctxt){
  /*
    Change context when loading a parameter file or running the demo
  */
    for (var id in ctxt) {
      var value = ctxt[id];

      if (typeof(value)=="boolean") {
        try {
          load_checkboxes(id, value);
        }
        catch(ex) {
          alert('Something is wrong in your SET UP FILE ! Check again ! (Press F12 to see the error !)')
          console.log(ex);
          throw(ex);
        }
      }
      else if ( id=="id_residus") {
        try {
          load_radios(id, value);
        }
        catch (ex) {
          alert('Something is wrong in your SET UP FILE ! Check again ! (Press F12 to see the error !)')
          console.log(ex);
          throw(ex);
        }
      }
      else if (hbv.c.twins.indexOf(id)>=0) {
        try {
          load_pars(id, value);
        }
        catch (ex) {
          alert('Something is wrong in your SET UP FILE ! Check again ! (Press F12 to see the error !)')
          console.log(ex);
          throw(ex);
        }
      }
      else if (id=="bounds") {
        try {
          load_bounds(value);
        }
        catch (ex) {
          alert('Something is wrong in your SET UP FILE ! Check again ! (Press F12 to see the error !)')
          console.log(ex);
          throw(ex);
        }
      }
      else if (id=="par_to_calibrate") {
        try {
          load_par_to_calibrate(value);
        }
        catch (ex) {
          alert('Something is wrong in your SET UP FILE ! Check again ! (Press F12 to see the error !)')
          console.log(ex);
          throw(ex);
        }
      }
      else {
        var elem =  $(`input[id=${id}]`);
        elem.value = value;
        (elem.is("[invalid]")) ? undefined : hbv.c.context[id] = value;
      }
    }

    function load_checkboxes(id, value) {
      var elem =  $(`input[id=${id}]`);
      (value) ? elem.prop("checked", true) : elem.prop("checked", false);
      (elem.is("[invalid]")) ? undefined : hbv.c.context[id] = value;
      // Trigger period_selector toggle transition
      (id=="id_select_date_range") ? elem.trigger("change") : undefined;
      return undefined;
    }

    function load_radios(id, value) {
      var elem =  $(`input[id=${id}]`);
      (ctxt[id]=="RMSE") ? $("#id_RMSE").prop("checked", true) : $("#id_NSE").prop("checked", false);
      (elem.is("[invalid]")) ? undefined : hbv.c.context[id] = value;
      return undefined;
    }

    function load_pars(id, value) {
      var elem =  $(`input[id=${id}]`);
      Object.values(elem).slice(0,2).forEach(function (element) {
        element.value = value;
        element.onchange();
        (element.hasAttribute("invalid")) ? undefined : hbv.c.context[id] = value;
      });
    }

    function load_bounds(value) {
      var lbs = Object.values($("#col_LB input"));
      var ubs = Object.values($("#col_UB input"));

      for (var i = value.P_LB.length - 1; i >= 0; i--) {
        var v = value.P_LB[i],
            vv = value.P_UB[i];

        if (typeof(v)=="number") {
          lbs[i].value = v;
        }
        else {
          if (isFloat(v)) {
            lbs[i].value = parseFloat(v);
          }
          else {
            throw new Error(`The ${i}th P_LB ${v} is inacceptable !`);
          }
        }

        if (typeof(vv)=="number") {
          ubs[i].value = vv;
        }
        else {
          if (isFloat(vv)){
            ubs[i].value = parseFloat(vv);
          }
          else{
            throw new Error(`The ${i}th P_UB ${vv} is inacceptable !`);
          }
        }
      }
    }

    function load_par_to_calibrate(value) {
      Object.keys(value).map(function(id){
        var box = $(`input[par][id=${id}]`).parent().find("input[type=checkbox]"),
            bol = value[id];
        if (typeof(bol)=="boolean") {
          box.prop("checked", bol);
        }
        else if (bol.toLowerCase()=="true") {
          box.prop("checked", true);
        }
        else if (bol.toLowerCase()=="false") {
          box.prop("checked", false);
        }
        else {
          throw new Error(`Something wrong in deciding wether to calibrate ${id}, Please check your setup file again !`);
        }
      });
    }
  }

  function sample() {
    var context = {
      "id_verbose":true,
      "id_minimise":true,
      "id_tolInput":"0.001",
      "id_warmUpInput":"10",
      "id_csvSeparatorInput":",",
      "id_csvHeaderInput":"0",
      "id_calibrate_all_par":true,
      "id_select_date_range":false,
      "id_sci_note":true,
      "id_snow":true,
      "init_guess":false,
      "id_residus":"RMSE",
      "id_perc":"0.1",
      "id_alpha":"0.5",
      "id_k1":"0.00005",
      "id_mbas":"1",
      "id_k":"0.01",
      "id_lz":"0",
      "id_uz":"0",
      "id_c_flux":"0.05",
      "id_beta":"3.5",
      "id_lp":"0.35",
      "id_etf":"2.5",
      "id_e_corr":"1.0",
      "id_fc":"250",
      "id_sm":"0",
      "id_cfr":"0.5",
      "id_cwh":"0.02",
      "id_cfmax":"0.1",
      "id_ttm":"0.1",
      "id_utt":"0.1",
      "id_ltt":"-0.1",
      "id_sfcf":"1.0",
      "id_rfcf":"1.0",
      "id_wc":"0",
      "id_sp":"0",
      "id_tfac":"24",
      "id_area":"135.0",
      "par_to_calibrate": { // Parameters to calibrate
        "id_perc":true,
        "id_alpha":true,
        "id_k1":true,
        "id_k":true,
        "id_c_flux":true,
        "id_beta":true,
        "id_lp":true,
        "id_etf":true,
        "id_e_corr":true,
        "id_fc":true,
        "id_cfr":true,
        "id_cwh":true,
        "id_cfmax":true,
        "id_ttm":true,
        "id_utt":true,
        "id_ltt":true,
        "id_sfcf":true,
        "id_rfcf":true,
      },
      "bounds":{
        P_LB:["0.6",      //rfcf
              "0.4",      //sfcf
              "-1.5",     //ltt
              "0.001",    //utt
              "0.001",    //ttm
              "0.04",     //cfmax [mm c^-1 h^-1]
              "0.001",    //cwh
              "0.01",     //cfr
              "50.0",     //fc
              "0.6",      //ecorr
              "0.001",    //etf
              "0.2",      //lp
              "1.0",      //beta
              "0.00042",  //k [h^-1] upper zone
              "0.0000042",//k1 lower zone
              "0.001",    //alpha
              "0.0",      //c_flux
              "0.001"],   //perc mm/h
        P_UB:["1.4",      //rfcf
              "1.4",      //sfcf
              "2.5",      //ltt
              "3.0",      //utt
              "2.0",      //ttm
              "0.4",      //cfmax [mm c^-1 h^-1]
              "0.1",      //cwh
              "1.0",      //cfr
              "500.0",    //fc
              "1.4",      //ecorr
              "5.0",      //etf
              "0.5",      //lp
              "6.0",      //beta
              "0.0167",   //k upper zone
              "0.00062",  //k1 lower zone
              "1.0",      //alpha
              "0.08",     //c_flux - 2mm/day
              "0.125"]    //perc mm/hr
      },
    };
    hbv.c.changeWhenLoad(context);
  }

  function load(jsn){
    return undefined;
  }

  function save(){
    var a = document.createElement("a");
    var now = moment();
    var name = `HBV96 setup ${now.format('YYYY-MM-DD')} at (${now.hour()}h${now.minute()}m${now.second()}s).json`;

    hbv.c.context.info = `This model configuration is genrated on: ${now._d}.`;

    var text = JSON.stringify(hbv.c.context);

    var file = new Blob([text], {type : 'application/json'});
    a.href = URL.createObjectURL(file);
    a.download = name;
    a.click();
  }

  return {context:context, twins:twins, changeWhenInput:changeWhenInput,
    changeWhenLoad:changeWhenLoad, sample:sample, save:save, load:load};
}
