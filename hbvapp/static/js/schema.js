/*
  plot.js contains functions to generate plots using library plotly.js. Plots
  generated by Bokeh python is not as interactive as expected. For example, it
  is hard to call a callback function when we want to use values on the graph.
  And another idea is that plotly.js is capable to append/add traces(glyphs)
  dynamically by updating data, which is more efficient and less complicated than
  using Bokeh to generate <div>s and <script>s sent by post.
*/

/*
  Prototype Schema contains the schema of the HBV tanks and the corresponding
  water levels in the thank. Basically we use D3.js here to realize both the static
  drawing and the transition. D3 will generate water tanks which are mainly static,
  and water levels controled by a scroll bar indicating time. To
  previlige D3's data-driven nature, we wi   ll use the DataFrame generated by pyhton
  as our input data here.
*/

function Schema() {
  var svg = d3.select(".schemaSvg"),
      p_width = [0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1, 1.125, 1.25],
      tanks = new Object(),
      extrems = new Object();

  // Value, a factor to multiple with tanks' heights
  var value = 0.75;

  // Minimum depth, to prevent zero or negative value
  var base = 0.05;

  // Maximal height of water levels
  var maxh = 0.85;

  function generate_key_cords(){
    var x = parseInt(this.svg.select("#main_soil").attr("x")),
        y = parseInt(this.svg.select("#main_soil").attr("y")),
        w_soil = parseInt(this.svg.select("#main_soil").attr("width")),
        h_soil = parseInt(this.svg.select("#main_soil").attr("height"));

    var soil = {
      x: x,
      y: y,
      width: w_soil,
      height: h_soil,
      stroke: 4,
      };

    var uz = {
      x: 60,
      y: 429,
      x1: 300,
      y1: 539,
      stroke: 4,
      get width() {
        return (this.x1-this.x);
      },
      get height() {
        return (this.y1-this.y);
      },
    };

    var lz = {
      x: 60,
      y: 616,
      x1: 300,
      y1: 726,
      stroke: 4,
      get width() {
        return (this.x1-this.x);
      },
      get height() {
        return (this.y1-this.y);
      },
    };

    var int_cords = {soil: soil, uz: uz, lz: lz};
    this.cords = int_cords;
  }

  function generate_main(name, cords) {
    var cord = cords[name];
    var value = this.value;
    var tank = this.svg.append("rect")
                      .attr("x", function(){
                        return (cord.x+0.6*cord.stroke);
                       })
                      .attr("y", function(){
                        return (cord.height*(1-value)+cord.y);
                       })
                      .attr("width", function(){
                        return cord.width-0.9*cord.stroke;
                       })
                      .attr("height", function(){
                        return parseInt(cord.height*value);
                       })
                      .attr("fill", "#3333cc")
                      .attr("fill-opacity", 0.4)
                      .attr("id", name);
    return tank;
  }

  function generate_shade(tank) {
    var name = tank.attr("id");
    var stroke = 4;

    var surf = this.svg.append("path")
                        .attr("stroke", "#0f0f3e")
                        .attr("stroke-width", 3)
                        .attr("stroke-opacity", 0.7)
                        .attr("class", "surf")
                        .attr("d", function(){
                          var x = tank.attr("x").toFloat();
                          var y = tank.attr("y").toFloat();
                          var length = tank.attr("width").toFloat();
                          return `M ${x} ${y} h ${length}`;
                        });

    var shade_clip = this.svg.append("clipPath")
                              .attr("id", `${name}_shade_container`)
                              .append("rect")
                              .attr("x", function(){return tank.attr('x').toFloat()+1;})
                              .attr("y", function(){return tank.attr('y').toFloat();})
                              .attr("width", function(){
                                var w = tank.attr('width').toFloat() - 2;
                                return w;
                              })
                              .attr("height", function(){
                                var h = tank.attr('height').toFloat() - 1;
                                return h;
                              })
                              .attr("fill", "#ccffff")
                              .attr("class", "shade_clip");

    var shade = this.svg.selectAll("#shade")
                        .data(this.p_width)
                        .enter()
                        .append("path")
                        .attr("d", function(d){
                          var x0 = tank.attr('x').toFloat() + tank.attr('width').toFloat() * d;
                          var y0 = tank.attr('y').toFloat();
                          var x1 = x0-tank.attr('height').toFloat();
                          var y1 = tank.attr('y').toFloat()+tank.attr('height').toFloat();
                          return `M ${x0} ${y0} L ${x1} ${y1}`;
                        })
                        .attr("stroke", "#3366ff")
                        .attr("stroke-width", 2)
                        .attr("stroke-opacity", 0.5)
                        .attr("clip-path", `url(#${name}_shade_container)`)
                        .attr("class", "shade");

    return {surf: surf, shade_clip: shade_clip, shade: shade, name: name};
  }

  function init_animation() {
    var value = this.value;
    var int_tanks = { mains: {}, shades: {} };
    this.generate_key_cords();

    int_tanks.mains.soil = this.generate_main('soil', this.cords);
    int_tanks.shades.soil = this.generate_shade(int_tanks.mains.soil);
    int_tanks.mains.uz = this.generate_main('uz', this.cords);
    int_tanks.shades.uz = this.generate_shade(int_tanks.mains.uz);
    int_tanks.mains.lz = this.generate_main('lz', this.cords);
    int_tanks.shades.lz = this.generate_shade(int_tanks.mains.lz);
    this.tanks = int_tanks;
    return undefined;
  }

  function trans(name, value) {
    var col_name = "";
    (name=="soil") ? col_name = "sm" : col_name = name;
    var maxh = this.maxh,
        base = this.base;

    var min = this.extrems[col_name][0],
        max = this.extrems[col_name][1];

    var fill = base+maxh*(value-min)/(max-min);

    var main = this.tanks.mains[name],
        shade = this.tanks.shades[name];

    var cords = this.cords[name];
    var ys = (cords.height*(1-fill)+cords.y).toFixed(2);
    var heights = (cords.height*fill).toFixed(2);

    main.transition()
        .attr("y", ys)
        .attr("height", heights);

    shade.surf.transition()
              .attr("d", function(){
                var x = main.attr("x").toFloat();
                var y = ys;
                var length = main.attr("width").toFloat();
                return `M ${x} ${y} h ${length}`;
              });

    shade.shade_clip.transition()
                    .attr("y", ys)
                    .attr("height", heights);

    shade.shade.transition()
               .attr("d", function(d){
                  var x0 = main.attr('x').toFloat() + main.attr('width').toFloat() * d;
                  var y0 = ys.toFloat();
                  var x1 = x0 - heights.toFloat();
                  var y1 = ys.toFloat() + heights.toFloat();
                  return `M ${x0} ${y0} L ${x1} ${y1}`;
                });
  }

  function point_to(index) {
    // df an object-like dataframe
    var df = hbv.d.data[this.latest];
    var time = df.time,
        sm = df.sm,
        uz = df.uz,
        lz = df.lz,
        wc = df.wc,
        sp = df.sp;

    this.trans("soil", sm[index]);
    this.trans("uz", uz[index]);
    this.trans("lz", lz[index]);
  }

  function init_slider() {
    var terminus = hbv.d.init_data.length-1;

    if (isEmpty(hbv.d.data)) {
      $("#id_time_slider").prop("disabled", true);
      alert("It seems that we have no data ! ");
    }
    else {
      if ($("#id_time_slider").prop("disabled")) {
        $("#id_time_slider").prop("disabled", false)
                            .prop("max", terminus)
                            .prop("this.value", 0);
      } else {
        $("#id_time_slider").prop("max", terminus)
                            .prop("value", 0);
      }
    }
  }

  function set_local_extrems(left, right) {
    for (col_name of ["sm", "uz", "lz"]){
      var max = hbv.d.find_max(col_name, this.latest, left, right),
          min = hbv.d.find_min(col_name, this.latest, left, right);

      this.extrems[col_name] = [min, max];
    }

    // Issue#1 : Compare the desired min/max with current ones
    if (left > $("#id_time_slider").attr("max")) {
      $("#id_time_slider").prop("max", right)
                          .prop("value", left)
                          .prop("min", left);
    } else if (right < $("#id_time_slider").attr("min")) {
      $("#id_time_slider").prop("min", left)
                          .prop("value", left)
                          .prop("max", right);
    } else {
      $("#id_time_slider").prop("min", left)
                          .prop("value", left)
                          .prop("max", right);
    }

    return undefined;
  }

  // Prototype constructor interface
  var schema = {
    get latest() {  // Latest set of data
      var latest = hbv.d.data.length-1;
      return latest;
    },
    svg:svg, p_width:p_width, tanks:tanks, base:base, maxh:maxh, value:value,
    generate_key_cords:generate_key_cords, init_slider:init_slider,
    generate_main:generate_main, generate_shade:generate_shade,
    init_animation:init_animation, trans:trans, point_to:point_to,
    set_local_extrems:set_local_extrems, extrems:extrems,
  };
  return schema;
}
