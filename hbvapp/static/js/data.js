/*
  plot.js contains functions to generate plots using library plotly.js. Plots
  generated by Bokeh python is not as interactive as expected. For example, it
  is hard to call a callback function when we want to use values on the graph.
  And another idea is that plotly.js is capable to append/add traces(glyphs)
  dynamically by updating data, which is more efficient and less complicated than
  using Bokeh to generate <div>s and <script>s sent by post.
*/

/*
  Prototype Schema contains the schema of the HBV tanks and the corresponding
  water levels in the thank. Basically we use D3.js here to realize both the static
  drawing and the transition. D3 will generate water tanks which are mainly static,
  and water levels controled by a scroll bar indicating time. To
  previlige D3's data-driven nature, we will use the DataFrame generated by pyhton
  as our input data here.
*/

// Data object constructors
function Data () {
  var init_data = new Array();
  var data = new Array();
  var inters = new Array();
  var regime = new Array();
  var info = new Array(); // Information, array of DataInfo objects

  function initialize(text) {
  /*
    Function to read parse local csv text and generate init_data of Data object
  */
    var delimiter = hbv.c.context.id_csvSeparatorInput,
        header = parseInt(hbv.c.context.id_csvHeaderInput);

    var data = d3.dsvFormat(delimiter).parse(text, function(d, i) {
      return {
        time: moment(d.time).format("YYYY-MM-DD HH:mm:ss"),  // Date
        prec: +d.prec,     // Precipitation
        q_rec: +d.q_rec,   // Recorded discharge
        temp: +d.temp,     // Air temperature
        tm: +d.tm,         // Monthly mean air temperature
        ep: +d.ep,         // Evaporation
        };
      });

    this.init_data = data;

    if (!hbv.c.context.push) {
      // Reset/Clear existing info
      this.info.length =0;
    } else {undefined;}
    this.info.push(new DataInfo(null, null, this.check_time_range()));

    // Extract mont, create month column
    if (this.info.last().time_range === "y") {
      this.init_data.forEach(extract_month);
    }
    return undefined;
  } // <-- initialize -->

  function check_time_range() {
    var last_step = moment.utc(this.init_data.last().time),
        first_step = moment.utc(this.init_data[0].time),
        time_range = last_step.diff(first_step, "hours");

    if (time_range >= 8760) {
      return "y";
    }
    else if (time_range >= 4320) {
      return "6m";
    }
    else if (time_range >= 720) {
      return "m";
    }
    else if (time_range >= 24) {
      return "d";
    }
    else if (time_range >= 1) {
      return "h";
    }
    else {
      return "<1h";
    }
  }

  function extract_month(row) {
    /*
      Extract month of each row in the time series to help generating bassin regime
    */
    row.month = parseInt(row.time.substr(5,7));
    return undefined;
  }

  function synthesize(d, ints) {
  /*
    synthesize() generates a dataframe-like js object to serve as Data.data
    element.
    Inputs:
    d : np.array-like data frame by POST, already has simulation results.
    ints : np.array-like data frame by POST, intermediate values during simulation.
  */
    var dat = new Object(),
        inter = new Object(),
        maxis = new Object(),
        minis = new Object(),
        regi = new Object();

    // Extreme values
    var names = ['time', 'q_rec', 'q_sim', 'ep', 'temp', 'tm', 'prec', 'sp','wc', 'sm', 'lz', 'uz'];
    for (var col_name of names) {
      var col = d.map(function(row){
        return row[col_name];
      });
      dat[col_name] = col;
      if (col_name!="time") {
        maxis[col_name] = Math.max.apply(null, col);
        minis[col_name] = Math.min.apply(null, col);
      } else {undefined;}
    }

    // Intermediate values
    names = ['r', 'cf', 'gw'];
    for (var col_name of names) {
      var col = ints.map(function(row){
        return row[col_name];
      });
      inter[col_name] = col;
      maxis[col_name] = Math.max.apply(null, col);
      minis[col_name] = Math.min.apply(null, col);
    }

    // Create basin regime
    if (this.info.last().time_range === "y") {
      for (var i = 11; i >= 0; i--) {
          regi[i] = {q_rec: [], q_sim: [], prec: []};
      }

      d.map(function(row){
        var ind = row.month-1;
        regi[ind].q_rec.push(row.q_rec);
        regi[ind].q_sim.push(row.q_sim);
        regi[ind].prec.push(row.prec);
      });

      var _regi = {q_rec: [], q_sim: [], prec: [], };
      for (var i = 11; i >= 0; i--) {
        for (var key in regi[i]) {
          _regi[key].push(d3.mean(regi[i][key]));
        }
      }
      _regi.month = ["Jan.", "Feb.", "Mar.", "Apr.", "May", "Jun.",
                      "Jul.", "Aug.", "Sept.", "Oct.", "Nov.", "Dec."];
    }

    // Push mode
    if (!hbv.c.context.push) {
      // Reset/Clear existing data
      this.data.length = 0;
      this.inters.length = 0;
      this.regime.length = 0;
    } else {undefined;}

    this.data.push(dat);
    this.inters.push(inter);
    if (this.data.length > this.info.length) {
      this.info.push(new DataInfo(maxis, minis));
    } else {
      this.info.last().set_m_values(maxis, minis, this.check_time_range());
    }
    (this.info.last().time_range === "y") ? this.regime.push(_regi) : undefined;

    return undefined;
  } // <-- synthesize -->

  function find_max(name, i, begin, end) {
  /*
    Function to find maxi in the given array
  */
    var max = Math.max.apply(Math, this.data[i][name].slice(begin, end+1));
    if (max == NaN) {
      var ex = new Error(`Gap presents in the ${name} data !`);
      throw ex;
    }
    else {
      return max;
    }
  }

  function find_min(name, i, begin, end) {
  /*
    Function to find mini in the given array
  */
    var min = Math.min.apply(Math, this.data[i][name].slice(begin, end+1));
    if (min == NaN) {
      var ex = new Error(`Gap presents in the ${name} data !`);
      throw ex;
    }
    else {
      return min;
    }
  }

  function show(i) {
    /*
      Show desired data with index i in the latest out put.
    */
    var data = hbv.d.data.last();
    var d = {};
    Object.entries(data).forEach(function(e){
      d[e[0]] = e[1][i];
    });
    console.log(i,d);

    $("#tag_time").html(d.time);
    if (hbv.c.context.id_sci_note) {
      $("table #q_sim").html(d.q_sim.toExponential(3));
      $("table #q_rec").html(d.q_rec.toExponential(3));
      $("table #prec").html(d.prec.toExponential(3));
      $("table #ep").html(d.ep.toExponential(3));
      $("table #sm").html(d.sm.toExponential(3));
      $("table #uz").html(d.uz.toExponential(3));
      $("table #lz").html(d.lz.toExponential(3));
    }
    else{
      $("table #q_sim").html(d.q_sim.toFixed(3));
      $("table #q_rec").html(d.q_rec.toFixed(3));
      $("table #prec").html(d.prec.toFixed(3));
      $("table #ep").html(d.ep.toFixed(3));
      $("table #sm").html(d.sm.toFixed(3));
      $("table #uz").html(d.uz.toFixed(3));
      $("table #lz").html(d.lz.toFixed(3));
    }
    return undefined;
  }

  return {init_data:init_data, data:data, find_max:find_max, find_min:find_min,
    initialize:initialize, synthesize:synthesize, info:info, inters:inters,
    regime:regime, show:show, check_time_range:check_time_range};
}

function DataInfo(maxis, minis, time_range) {
  /*
    A prototype to serve as data infomation records
  */
  this.maxis = maxis || {}; // Object storing maximal values
  this.minis = minis || {}; // Object storing minimal values
  this.first_step = moment.utc(hbv.d.init_data[0].time) || null; // First time step
  this.last_step = moment.utc(hbv.d.init_data[hbv.d.init_data.length-1].time) || null; // Last time step
  this.time_step = moment.utc(hbv.d.init_data[1].time).diff(this.first_step, "seconds");
  this.len = hbv.d.init_data.length;
  this.time_range = time_range || null;
  this.set_m_values = function(maxs, mins) {
    this.maxis = maxs;
    this.minis = mins;
    return this;
  }
}
